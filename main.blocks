<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="I.~ZEw!Vll{MYmA(P:]P" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="V6h8IF)2.5dCnEIBLh*7" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Kulbot_demo1 {" line1="" line2="    export enum startbit_Colors {" line3="        //% block=&quot;Red&quot;" line4="        Red = 0x01," line5="        //% block=&quot;Green&quot;" line6="        Green = 0x02," line7="        //% block=&quot;Blue&quot;" line8="        Blue = 0x03," line9="        //% block=&quot;Black&quot;" line10="        Black = 0x04," line11="        //% block=&quot;White&quot;" line12="        White = 0x05," line13="        //% block=&quot;None&quot;" line14="        None = 0x06" line15="    }" line16="" line17="    export enum startbit_lineFollower {" line18="        //% blockId=&quot;S1_OUT_S2_OUT&quot; block=&quot;Sensor1 and sensor2 are out black line&quot;" line19="        S1_OUT_S2_OUT = 0x00," line20="        //% blockId=&quot;S1_OUT_S2_IN&quot; block=&quot;Sensor2 in black line but sensor1 not&quot;" line21="        S1_OUT_S2_IN = 0x01," line22="        //% blockId=&quot;S1_IN_S2_OUT&quot; block=&quot;Sensor1 in black line but sensor2 not&quot;" line23="        S1_IN_S2_OUT = 0x02," line24="        //% blockId=&quot;S1_IN_S2_IN&quot; block=&quot;Sensor1 and sensor2 are in black line &quot;" line25="        S1_IN_S2_IN = 0x03" line26="    }" line27="" line28="    export enum startbit_colorSensorPort {" line29="        //% block=&quot;Port 4&quot;" line30="        port4 = 0x04" line31="    }" line32="    export enum startbit_LCDPort {" line33="        //% block=&quot;Port 4&quot;" line34="        port4 = 0x04" line35="    }" line36="    export enum startbit_Servos {" line37="        //% block=&quot;servo 1&quot;" line38="        Servo1 = 0x01," line39="        //% block=&quot;servo 2&quot;" line40="        Servo2 = 0x02" line41="    }" line42="" line43="    export enum startbit_ultrasonicPort {" line44="        //% block=&quot;Port 1&quot;" line45="        port1 = 0x01," line46="        //% block=&quot;Port 2&quot;" line47="        port2 = 0x02" line48="    }" line49="" line50="    export enum startbit_touchKeyPort {" line51="        //% block=&quot;Port 1&quot;" line52="        port1 = 0x01," line53="        //% block=&quot;Port 2&quot;" line54="        port2 = 0x02," line55="        //% block=&quot;Port 3&quot;" line56="        port3 = 0x03" line57="    }" line58="" line59="    export enum startbit_lineFollowPort {" line60="        //% block=&quot;Port 1&quot;" line61="        port1 = 0x01" line62="    }" line63="" line64="" line65="    export enum startbit_PinIOStatus {" line66="        //% block=&quot;Low&quot;" line67="        Low = 0x00," line68="        //% block=&quot;High&quot;" line69="        Hight = 0x01" line70="    }" line71="" line72="    export enum startbit_LineFollowerSensor {" line73="        //% block=&quot;Sensor 1&quot;" line74="        LFSensor_1 = 0x00," line75="        //% block=&quot;Sensor 2&quot;" line76="        LFSensor_2 = 0x01" line77="    }" line78="" line79="    export enum startbit_busServoPort {" line80="        //% block=&quot;Port 6&quot;" line81="        port6 = 0x06" line82="    }" line83="" line84="    export enum startbit_knobPort {" line85="        //% block=&quot;Port 1&quot;" line86="        port1 = 0x01" line87="    }" line88="&#9;" line89="    export enum startbit_photosensitivePort {" line90="        //% block=&quot;Port 1&quot;" line91="        port1 = 0x01&#9;    " line92="    }" line93="&#9;" line94="    export enum startbit_PhotosensitiveSensor {" line95="        //% block=&quot;Port 1&quot;" line96="        port1 = 0x00&#9;    " line97="    }" line98="" line99="    export enum startbit_fanPort {" line100="        //% block=&quot;Port 1&quot;" line101="        port1," line102="        //% block=&quot;Port 2&quot;" line103="        port2" line104="    }" line105="" line106="    export enum startbit_servorange {" line107="        //% block=&quot;180&quot;" line108="        range1 = 180," line109="        //% block=&quot;270&quot;" line110="        range2 =270" line111="    }" line112="&#9;" line113="    export enum startbit_digitaltubePort {" line114="        //% block=&quot;Port 1&quot;" line115="        port1 = 0x01," line116="        //% block=&quot;Port 2&quot;" line117="        port2 = 0x02" line118="    }" line119="&#9;" line120="    export enum startbit_CmdType {" line121="        //% block=&quot;Invalid command&quot;" line122="        NO_COMMAND = 0," line123="        //% block=&quot;car run&quot;" line124="        CAR_RUN = 1," line125="&#9;    //% block=&quot;robot run&quot;   " line126="&#9;    ROBOT_RUN = 1," line127="        //% block=&quot;Servo&quot;" line128="        SERVO = 2," line129="        //% block=&quot;Ultrasonic distance&quot;" line130="        ULTRASONIC = 3," line131="        //% block=&quot;Temperature&quot;" line132="        TEMPERATURE = 4," line133="        //% block=&quot;Sound&quot;" line134="        SOUND = 5," line135="        //% block=&quot;Light&quot;" line136="        LIGHT = 6," line137="        //% block=&quot;Voltage&quot;" line138="        BAT = 7," line139="        //% block=&quot;Rgb light&quot;" line140="        RGB_LIGHT = 8," line141="        //% block=&quot;Honk horn&quot;" line142="        DIDI = 9," line143="        //% block=&quot;Read firmware version&quot;" line144="        VERSION = 10," line145="        //% block=&quot;Read angle&quot;" line146="        READ_ANGLE = 11," line147="        //% block=&quot;Light belt&quot;        " line148="        RGB_BELT = 12," line149="        //% block=&quot;WIFI mode&quot;" line150="        WIFI_MODE = 13," line151="        //% block=&quot;Get mac&quot;" line152="        GET_MAC = 14," line153="        //% block=&quot;Get hand cmd&quot;" line154="        GET_HAND_CMD = 15" line155="     }" line156="" line157="    export enum startbit_CarRunCmdType {" line158="        //% block=&quot;Stop&quot;" line159="        STOP = 0," line160="        //% block=&quot;Go ahead&quot;" line161="        GO_AHEAD," line162="        //% block=&quot;Back&quot;" line163="        GO_BACK," line164="        //% block=&quot;Turn left&quot;" line165="        TURN_LEFT," line166="        //% block=&quot;Turn right&quot;" line167="        TURN_RIGHT," line168="        //% block=&quot;Go ahead slowly&quot;" line169="        GO_AHEAD_SLOW," line170="        //% block=&quot;Turn left slowly&quot;" line171="        TURN_LEFT_SLOW," line172="        //% block=&quot;Turn right slowly&quot;" line173="        TURN_RIGHT_SLOW," line174="        //% block=&quot;Invalid command&quot;" line175="        COMMAND_ERRO" line176="    }" line177="" line178="    export enum I2C_ADDR {" line179="        //% block=&quot;0x27&quot;" line180="        addr1 = 0x27," line181="        //% block=&quot;0x3f&quot;" line182="        addr2 = 0x3f," line183="        //% block=&quot;0x20&quot;" line184="        addr3 = 0x20," line185="        //% block=&quot;0x62&quot;" line186="        addr4 = 0x62," line187="        //% block=&quot;0x3e&quot;" line188="        addr5 = 0x3e" line189="    }" line190="    export enum on_off {" line191="        //% block=&quot;on&quot;" line192="        on = 1," line193="        //% block=&quot;off&quot;" line194="        off = 0" line195="    }" line196="" line197="    export enum visibled {" line198="        //% block=&quot;visibled&quot;" line199="        visible = 1," line200="        //% block=&quot;invisibled&quot;" line201="        invisible = 0" line202="    }" line203="" line204="" line205="    /**" line206="     * Startbit initialization, please execute at boot time" line207="    */" line208="    //% weight=100 blockId=startbit_Init block=&quot;Initialize Startbit&quot; group=&quot;0. Set up.&quot;" line209="    export function startbit_Init() {" line210="        startbit_initRGBLight();" line211="        " line212="        basic.pause(2000);" line213="    }" line214="" line215="" line216="    let handleCmd: string = &quot;&quot;;" line217="    let currentVoltage: number = 0;" line218="    let volume: number = 0;" line219="    let lhRGBLight: StartbitRGBLight.LHstartbitRGBLight;" line220="    let lhRGBLightBelt: StartbitRGBLight.LHstartbitRGBLight;" line221="" line222="    let P14_ad = 0;" line223="    let MESSAGE_MAC = 0xff;" line224="    let MESSAGE_ANGLE = 0x100;" line225="" line226="    let i2cPortValid: boolean = true;" line227="    let connectStatus: boolean = false;" line228="" line229="    let servo1Angle: number = 0xfff;" line230="    let servo2Angle: number = 0xfff;" line231="" line232="    let macStr: string = &quot;&quot;;" line233="    let actiongroup_finished = true;" line234="    " line235="    let Digitaltube:startbit_TM1640LEDs" line236="    let TM1640_CMD1 = 0x40;" line237="    let TM1640_CMD2 = 0xC0;" line238="    let TM1640_CMD3 = 0x80;" line239="    let _SEGMENTS = [0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71];" line240="&#9;" line241="    " line242="" line243="" line244="" line245="    " line246="" line247="    /**" line248="    * Set the angle of servo 1 to 6, range of 0~270 degree" line249="    */" line250="    //% weight=99 blockId=setServo block=&quot;Set pwm servo range|range %range|index %index|angle %angle|duration %duration&quot; group=&quot;2. Servo-Motor.&quot;" line251="    //% angle.min=0 angle.max=270" line252="    //% inlineInputMode=inline" line253="    export function setServo(range:startbit_servorange, index: number = 1, angle: number, duration: number = 300) {" line254="&#9;    " line255="        let position = mapRGB(angle, 0, range, 500, 2500);" line256="" line257="        let buf = pins.createBuffer(10);" line258="        buf[0] = 0x55;" line259="        buf[1] = 0x55;" line260="        buf[2] = 0x08;" line261="        buf[3] = 0x03;//cmd type" line262="        buf[4] = 0x01;" line263="        buf[5] = duration &amp; 0xff;" line264="        buf[6] = (duration &gt;&gt; 8) &amp; 0xff;" line265="        buf[7] = index;" line266="        buf[8] = position &amp; 0xff;" line267="        buf[9] = (position &gt;&gt; 8) &amp; 0xff;" line268="        serial.writeBuffer(buf);" line269="    }" line270="" line271="&#9;" line272="    /**" line273="    * Set the servo controller to run a actiongroup" line274="    * @param times Running times. eg: 1" line275="    */" line276="    //% weight=96 blockId=startbit_runActionGroup block=&quot;Run ActionGroup|index %index|times %times&quot; group=&quot;2. Servo-Motor.&quot; advanced=true" line277="    export function startbit_runActionGroup(index: number, times: number = 1) {" line278="" line279="        let buf2 = pins.createBuffer(7);" line280="        buf2[0] = 0x55;" line281="        buf2[1] = 0x55;" line282="        buf2[2] = 0x05;" line283="        buf2[3] = 0x06;//cmd type CMD_ACTION_GROUP_RUN" line284="        buf2[4] = index &amp; 0xff;" line285="        buf2[5] = times &amp; 0xff;" line286="        buf2[6] = (times &gt;&gt; 8) &amp; 0xff;" line287="" line288="        actiongroup_finished = false;" line289="        serial.writeBuffer(buf2);" line290="    }" line291="&#9;" line292="    /**" line293="    * Stop running actiongroup" line294="    */" line295="    //% weight=95 blockId=startbit_stopnActionGroup block=&quot;Stop ActionGroup&quot; group=&quot;2. Servo-Motor.&quot; advanced=true" line296="    export function startbit_stopActionGroup() {" line297="" line298="        let buf3 = pins.createBuffer(7);" line299="        buf3[0] = 0x55;" line300="        buf3[1] = 0x55;" line301="        buf3[2] = 0x02;" line302="        buf3[3] = 0x07;//cmd type CMD_ACTION_GROUP_STOP" line303="&#9;    " line304="&#9;actiongroup_finished = false;" line305="        serial.writeBuffer(buf3);" line306="    }" line307="&#9;" line308="    /**" line309="     * Wait for Actiongroup Finishing" line310="     */" line311="    //% weight=94 blockId=startbit_actionRunover block=&quot;Action run over&quot; group=&quot;2. Servo-Motor.&quot; advanced=true" line312="    export function startbit_actionRunover(): boolean {" line313="        // let ret = false;" line314="        if (actiongroup_finished == true) {" line315="            // ret = true;" line316="            actiongroup_finished = true;" line317="        }" line318="        else {" line319="            actiongroup_finished = false;" line320="        }" line321="        return actiongroup_finished;" line322="    }" line323="" line324="&#9;" line325="    /**" line326="     * Send read startbit servos angle command" line327="     */" line328="    //% weight=92 blockId=startbit_readAngle block=&quot;Send |%servo|angle command &quot; group=&quot;2. Servo-Motor.&quot; advanced=true" line329="    export function startbit_readAngle(servo: startbit_Servos) {" line330="        let buf4 = pins.createBuffer(6);" line331="        buf4[0] = 0x55;" line332="        buf4[1] = 0x55;" line333="        buf4[2] = 0x04;" line334="        buf4[3] = 0x3E;//cmd type" line335="        buf4[4] = 0x05;" line336="        buf4[5] = servo;" line337="        serial.writeBuffer(buf4);" line338="    }" line339="" line340="" line341="    /**" line342="     * Do someting when Startbit receive angle" line343="     * @param body code to run when event is raised" line344="     */" line345="    //% weight=90 blockId=onStartbit_getAngle block=&quot;on Startbit|%servo|get angle&quot; group=&quot;2. Servo-Motor.&quot; advanced=true" line346="    export function onStartbit_getAngle(servo: startbit_Servos, body: Action) {" line347="        control.onEvent(MESSAGE_ANGLE, servo, body);" line348="    }" line349="" line350="" line351="    /**" line352="     *  Get servos angle" line353="     */" line354="    //% weight=88 blockId=getServosAngle blockGap=50 block=&quot;Get|%servo|angle(-120~120)&quot; group=&quot;2. Servo-Motor.&quot; advanced=true" line355="    export function getServosAngle(servo: startbit_Servos): number {" line356="        if (servo == startbit_Servos.Servo1) {" line357="            return servo1Angle;" line358="        }" line359="        else if (servo == startbit_Servos.Servo2) {" line360="            return servo2Angle;" line361="        }" line362="        else" line363="            return 0xFFF;" line364="    }" line365="    " line366="    /**" line367="     *  Send robot attitude to the servo controller" line368="     *  @param pitch eg: 0" line369="     *  @param roll eg: 0" line370="     */" line371="    //% weight=91 blockId=startbit_sendAttitude block=&quot;Send pitch|%pitch|and roll|%roll&quot;" line372="   /*" line373="    export function startbit_sendAttitude(pitch: number, roll: number) {" line374="        pitch &lt; -90 ? -90 : pitch;" line375="        pitch &gt; 90 ? 90 : pitch;" line376="        roll &lt; -90 ? -90 : roll;" line377="        roll &gt; 90 ? 90 : roll;" line378="" line379="        let buf = pins.createBuffer(6);" line380="        buf[0] = 0x55;" line381="        buf[1] = 0x55;" line382="        buf[2] = 0x04;" line383="        buf[3] = 0x5A;" line384="        buf[4] = pitch;" line385="        buf[5] = roll;" line386="        serial.writeBuffer(buf);" line387="    }" line388="    */" line389="&#9;" line390="    /**" line391="    *&#9;Set the speed of the number 1 motor and number 2 motor, range of -100~100, that can control the tank to go advance or turn of." line392="    */" line393="    //% weight=86 blockId=startbit_setMotorSpeed  block=&quot;Set motor1 speed(-100~100)|%speed1|and motor2|speed %speed2&quot; group=&quot;2. Servo-Motor.&quot;" line394="    //% speed1.min=-100 speed1.max=100" line395="    //% speed2.min=-100 speed2.max=100" line396="    export function startbit_setMotorSpeed(speed1: number, speed2: number) {" line397="        if (speed1 &gt; 100 || speed1 &lt; -100 || speed2 &gt; 100 || speed2 &lt; -100) {" line398="            return;" line399="        }" line400="        speed1 = speed1 * -1;" line401="        speed2 = speed2 * -1;" line402="        let buf5 = pins.createBuffer(6);" line403="        buf5[0] = 0x55;" line404="        buf5[1] = 0x55;" line405="        buf5[2] = 0x04;" line406="        buf5[3] = 0x32;//cmd type" line407="        buf5[4] = speed1;" line408="        buf5[5] = speed2;" line409="        serial.writeBuffer(buf5);" line410="    }" line411="" line412="    /**" line413="    *&#9;Set the speed of the fan, range of -100~100. " line414="    */" line415="    //% weight=84 blockId=startbit_setFanSpeed  block=&quot;Set |%port fan speed(-100~100)|%speed1&quot; group=&quot;2. Servo-Motor.&quot; advanced=true" line416="    //% speed1.min=-100 speed1.max=100" line417="    export function startbit_setFanSpeed(port: startbit_fanPort, speed1: number) {" line418="        if (speed1 &gt; 100 || speed1 &lt; -100) {" line419="            return;" line420="        }" line421="        let pin1 = AnalogPin.P1;" line422="        let pin2 = AnalogPin.P2;" line423="" line424="        if (port == startbit_fanPort.port2) {" line425="            pin1 = AnalogPin.P13;" line426="            pin2 = AnalogPin.P14;" line427="        }" line428="        if (speed1 &lt; 0) {" line429="            pins.analogWritePin(pin2, 0);" line430="            pins.analogWritePin(pin1, pins.map(-speed1, 0, 100, 0, 1023));" line431="        }" line432="        else if (speed1 &gt; 0) {" line433="            pins.analogWritePin(pin1, 0);" line434="            pins.analogWritePin(pin2, pins.map(speed1, 0, 100, 0, 1023));" line435="        }" line436="        else {" line437="            pins.analogWritePin(pin2, 0);" line438="            pins.analogWritePin(pin1, 0);" line439="        }" line440="" line441="    }" line442="" line443="&#9;" line444="   " line445="" line446="    const APDS9960_I2C_ADDR = 0x39;" line447="    const APDS9960_ID_1 = 0xA8;" line448="    const APDS9960_ID_2 = 0x9C;" line449="    /* APDS-9960 register addresses */" line450="    const APDS9960_ENABLE = 0x80;" line451="    const APDS9960_ATIME = 0x81;" line452="    const APDS9960_WTIME = 0x83;" line453="    const APDS9960_AILTL = 0x84;" line454="    const APDS9960_AILTH = 0x85;" line455="    const APDS9960_AIHTL = 0x86;" line456="    const APDS9960_AIHTH = 0x87;" line457="    const APDS9960_PERS = 0x8C;" line458="    const APDS9960_CONFIG1 = 0x8D;" line459="    const APDS9960_PPULSE = 0x8E;" line460="    const APDS9960_CONTROL = 0x8F;" line461="    const APDS9960_CONFIG2 = 0x90;" line462="    const APDS9960_ID = 0x92;" line463="    const APDS9960_STATUS = 0x93;" line464="    const APDS9960_CDATAL = 0x94;" line465="    const APDS9960_CDATAH = 0x95;" line466="    const APDS9960_RDATAL = 0x96;" line467="    const APDS9960_RDATAH = 0x97;" line468="    const APDS9960_GDATAL = 0x98;" line469="    const APDS9960_GDATAH = 0x99;" line470="    const APDS9960_BDATAL = 0x9A;" line471="    const APDS9960_BDATAH = 0x9B;" line472="    const APDS9960_POFFSET_UR = 0x9D;" line473="    const APDS9960_POFFSET_DL = 0x9E;" line474="    const APDS9960_CONFIG3 = 0x9F;" line475="    const APDS9960_GCONF4 = 0xAB;" line476="    const APDS9960_AICLEAR = 0xE7;" line477="" line478="" line479="    /* LED Drive values */" line480="    const LED_DRIVE_100MA = 0;" line481="" line482="    /* ALS Gain (AGAIN) values */" line483="    const AGAIN_4X = 1;" line484="" line485="    /* Default values */" line486="    const DEFAULT_ATIME = 219;    // 103ms" line487="    const DEFAULT_WTIME = 246;    // 27ms" line488="    const DEFAULT_PROX_PPULSE = 0x87;    // 16us, 8 pulses" line489="    const DEFAULT_POFFSET_UR = 0;       // 0 offset" line490="    const DEFAULT_POFFSET_DL = 0;       // 0 offset      " line491="    const DEFAULT_CONFIG1 = 0x60;    // No 12x wait (WTIME) factor" line492="    const DEFAULT_AILT = 0xFFFF;  // Force interrupt for calibration" line493="    const DEFAULT_AIHT = 0;" line494="    const DEFAULT_PERS = 0x11;    // 2 consecutive prox or ALS for int." line495="    const DEFAULT_CONFIG2 = 0x01;    // No saturation interrupts or LED boost  " line496="    const DEFAULT_CONFIG3 = 0;       // Enable all photodiodes, no SAI" line497="    const DEFAULT_LDRIVE = LED_DRIVE_100MA;" line498="    const DEFAULT_AGAIN = AGAIN_4X;" line499="" line500="    const OFF = 0;" line501="    const POWER = 0;" line502="    const AMBIENT_LIGHT = 1;" line503="    const ALL = 7;" line504="" line505="    const red_wb = 2130;" line506="    const green_wb = 3500;" line507="    const blue_wb = 4620;" line508="" line509="    function i2cwrite(reg: number, value: number) {" line510="        let buf6 = pins.createBuffer(2);" line511="        buf6[0] = reg;" line512="        buf6[1] = value;" line513="        pins.i2cWriteBuffer(APDS9960_I2C_ADDR, buf6);" line514="    }" line515="" line516="    function i2cread(reg: number): number {" line517="        pins.i2cWriteNumber(APDS9960_I2C_ADDR, reg, NumberFormat.UInt8BE);" line518="        let val = pins.i2cReadNumber(APDS9960_I2C_ADDR, NumberFormat.UInt8BE);" line519="        return val;" line520="    }" line521="" line522="" line523="    function InitColor(): boolean {" line524="        let id = i2cread(APDS9960_ID);" line525="        //  serial.writeLine(&quot;id:&quot;)" line526="        //  serial.writeNumber(id); " line527="        // if (!(id == APDS9960_ID_1 || id == APDS9960_ID_2)) {" line528="        //     return false;" line529="        // }" line530="        //  serial.writeLine(&quot;set mode:&quot;)" line531="        setMode(ALL, OFF);" line532="        i2cwrite(APDS9960_ATIME, DEFAULT_ATIME);" line533="        i2cwrite(APDS9960_WTIME, DEFAULT_WTIME);" line534="        i2cwrite(APDS9960_PPULSE, DEFAULT_PROX_PPULSE);" line535="        i2cwrite(APDS9960_POFFSET_UR, DEFAULT_POFFSET_UR);" line536="        i2cwrite(APDS9960_POFFSET_DL, DEFAULT_POFFSET_DL);" line537="        i2cwrite(APDS9960_CONFIG1, DEFAULT_CONFIG1);" line538="        setLEDDrive(DEFAULT_LDRIVE);" line539="        setAmbientLightGain(DEFAULT_AGAIN);" line540="        setLightIntLowThreshold(DEFAULT_AILT);" line541="        setLightIntHighThreshold(DEFAULT_AIHT);" line542="        i2cwrite(APDS9960_PERS, DEFAULT_PERS);" line543="        i2cwrite(APDS9960_CONFIG2, DEFAULT_CONFIG2);" line544="        i2cwrite(APDS9960_CONFIG3, DEFAULT_CONFIG3);" line545="        return true;" line546="    }" line547="" line548="    function setLEDDrive(drive: number) {" line549="        let val2 = i2cread(APDS9960_CONTROL);" line550="        /* Set bits in register to given value */" line551="        drive &amp;= 0b00000011;" line552="        drive = drive &lt;&lt; 6;" line553="        val2 &amp;= 0b00111111;" line554="        val2 |= drive;" line555="        i2cwrite(APDS9960_CONTROL, val2);" line556="    }" line557="" line558="    function setLightIntLowThreshold(threshold: number) {" line559="        let val_low = threshold &amp; 0x00FF;" line560="        let val_high = (threshold &amp; 0xFF00) &gt;&gt; 8;" line561="        i2cwrite(APDS9960_AILTL, val_low);" line562="        i2cwrite(APDS9960_AILTH, val_high);" line563="    }" line564="" line565="    function setLightIntHighThreshold(threshold: number) {" line566="        let val_low2 = threshold &amp; 0x00FF;" line567="        let val_high2 = (threshold &amp; 0xFF00) &gt;&gt; 8;" line568="        i2cwrite(APDS9960_AIHTL, val_low2);" line569="        i2cwrite(APDS9960_AIHTH, val_high2);" line570="    }" line571="" line572="" line573="    function rgb2hue(r: number, g: number, b: number): number {" line574="        let max = Math.max(r, Math.max(g, b))" line575="        let min = Math.min(r, Math.min(g, b))" line576="        let c = max - min;" line577="        let hue = 0;" line578="        let segment = 0;" line579="        let shift = 0;" line580="        if (c == 0)" line581="            return 0;" line582="        if ((r &gt; g) &amp;&amp; (r &gt; b)) {" line583="            segment = (60.0 * (g - b)) / c;" line584="            if (segment &lt; 0)" line585="                hue = segment + 360;" line586="        }" line587="        else if ((g &gt; b) &amp;&amp; (g &gt; r)) {" line588="            segment = (60.0 * (b - r)) / c;" line589="            hue = segment + 120;" line590="        }" line591="        else if ((b &gt; g) &amp;&amp; (b &gt; r)) {" line592="            segment = (60.0 * (r - g)) / c;" line593="            hue = segment + 240;" line594="        }" line595="        return hue;" line596="    }" line597="" line598="    function setMode(mode: number, enable: number) {" line599="        let reg_val = getMode();" line600="        /* Change bit(s) in ENABLE register */" line601="        enable = enable &amp; 0x01;" line602="        if (mode &gt;= 0 &amp;&amp; mode &lt;= 6) {" line603="            if (enable &gt; 0) {" line604="                reg_val |= (1 &lt;&lt; mode);" line605="            }" line606="            else {" line607="                //reg_val &amp;= ~(1 &lt;&lt; mode);" line608="                reg_val &amp;= (0xff - (1 &lt;&lt; mode));" line609="            }" line610="        }" line611="        else if (mode == ALL) {" line612="            if (enable &gt; 0) {" line613="                reg_val = 0x7F;" line614="            }" line615="            else {" line616="                reg_val = 0x00;" line617="            }" line618="        }" line619="        i2cwrite(APDS9960_ENABLE, reg_val);" line620="    }" line621="" line622="    function getMode(): number {" line623="        let enable_value = i2cread(APDS9960_ENABLE);" line624="        return enable_value;" line625="    }" line626="" line627="    function enableLightSensor(interrupts: boolean) {" line628="        setAmbientLightGain(DEFAULT_AGAIN);" line629="        if (interrupts) {" line630="            setAmbientLightIntEnable(1);" line631="        }" line632="        else {" line633="            setAmbientLightIntEnable(0);" line634="        }" line635="        enablePower();" line636="        setMode(AMBIENT_LIGHT, 1);" line637="    }" line638="" line639="    function setAmbientLightGain(drive: number) {" line640="        let val3 = i2cread(APDS9960_CONTROL);" line641="        /* Set bits in register to given value */" line642="        drive &amp;= 0b00000011;" line643="        val3 &amp;= 0b11111100;" line644="        val3 |= drive;" line645="        i2cwrite(APDS9960_CONTROL, val3);" line646="    }" line647="" line648="    function getAmbientLightGain(): number {" line649="        let val4 = i2cread(APDS9960_CONTROL);" line650="        val4 &amp;= 0b00000011;" line651="        return val4;" line652="    }" line653="" line654="    function enablePower() {" line655="        setMode(POWER, 1);" line656="    }" line657="" line658="    function setAmbientLightIntEnable(enable: number) {" line659="        let val5 = i2cread(APDS9960_ENABLE);" line660="        /* Set bits in register to given value */" line661="        enable &amp;= 0b00000001;" line662="        enable = enable &lt;&lt; 4;" line663="        val5 &amp;= 0b11101111;" line664="        val5 |= enable;" line665="        i2cwrite(APDS9960_ENABLE, val5);" line666="    }" line667="" line668="    function readAmbientLight(): number {" line669="        let val6 = i2cread(APDS9960_CDATAL);" line670="        let val_byte = i2cread(APDS9960_CDATAH);" line671="        val6 = val6 + val_byte * 256;" line672="        return val6;" line673="    }" line674="" line675="" line676="    /**" line677="     * Initialize the color sensor,please execute at boot time" line678="     */" line679="    //% weight=87 blockId=startbit_init_colorSensor block=&quot;Initialize color sensor port at %port&quot; group=&quot;1. Declaration.&quot;" line680="    export function startbit_init_colorSensor(port: startbit_colorSensorPort) {" line681="        InitColor();" line682="        enableLightSensor(true);" line683="        control.waitMicros(100);" line684="    }" line685="" line686="    /**" line687="&#9; *  Color sensor return the color." line688="&#9; */" line689="    //% weight=86 blockId=startbit_checkCurrentColor block=&quot;Current color %color&quot; group=&quot;3. Sensor.&quot; " line690="    export function startbit_checkCurrentColor(color: startbit_Colors): boolean {" line691="        let d = i2cread(APDS9960_CDATAL) + i2cread(APDS9960_CDATAH) * 256;" line692="        let r = i2cread(APDS9960_RDATAL) + i2cread(APDS9960_RDATAH) * 256;" line693="        let g = i2cread(APDS9960_GDATAL) + i2cread(APDS9960_GDATAH) * 256;" line694="        let b = i2cread(APDS9960_BDATAL) + i2cread(APDS9960_BDATAH) * 256;" line695="" line696="        // serial.writeNumber(c);" line697="        // serial.writeLine(&quot;-&gt;ccc&quot;);" line698="        // serial.writeNumber(r);" line699="        // serial.writeLine(&quot;-&gt;red&quot;);" line700="        // serial.writeNumber(g);" line701="        // serial.writeLine(&quot;-&gt;green&quot;);" line702="        // serial.writeNumber(b);" line703="        // serial.writeLine(&quot;-&gt;blue&quot;);" line704="" line705="        if (r &gt; red_wb)" line706="            r = red_wb;" line707="        if (g &gt; green_wb)" line708="            g = green_wb;" line709="        if (b &gt; blue_wb)" line710="            b = blue_wb;" line711="" line712="        r = Math.round(mapRGB(r, 0, red_wb, 0, 255));" line713="        g = Math.round(mapRGB(g, 0, green_wb, 0, 255));" line714="        b = Math.round(mapRGB(b, 0, blue_wb, 0, 255));" line715="        // serial.writeNumber(r);" line716="        // serial.writeLine(&quot;-&gt;rred&quot;);" line717="        // serial.writeNumber(g);" line718="        // serial.writeLine(&quot;-&gt;ggreen&quot;);" line719="        // serial.writeNumber(b);" line720="        // serial.writeLine(&quot;-&gt;bblue&quot;);" line721="         let hsv = rgb2hue(r, g, b);" line722="        // serial.writeNumber(hsv);" line723="        // serial.writeLine(&quot;-&gt;hsv&quot;);" line724="        let t = startbit_Colors.None;" line725="        if (d &gt; 2200 &amp;&amp; r &gt; 65 &amp;&amp; g &gt; 65 &amp;&amp; b &gt; 65) {" line726="            t = startbit_Colors.White;" line727="        }" line728="        else if (d &gt; 800) {" line729="            if (hsv &lt; 8 || hsv &gt; 350)" line730="                t = startbit_Colors.Red;" line731="            else if (hsv &gt; 60 &amp;&amp; hsv &lt; 170) {" line732="                t = startbit_Colors.Green;" line733="            }" line734="            else if (hsv &gt; 210 &amp;&amp; hsv &lt; 230) {" line735="                t = startbit_Colors.Blue;" line736="            }" line737="        }" line738="        else if (d &gt; 200 &amp;&amp; r &gt; 10 &amp;&amp; g &gt; 7 &amp;&amp; b &gt; 7 &amp;&amp; r &lt; 16.5 &amp;&amp; g &lt; 15 &amp;&amp; b &lt; 14) {" line739="            t = startbit_Colors.Black;" line740="        }" line741="        return (color == t);" line742="    }" line743="    /**" line744="    * Get the volume level detected by the sound sensor, range 0 to 255" line745="    */" line746="    //% weight=82 blockId=startbit_getSoundVolume block=&quot;Sound volume&quot; group=&quot;3. Sensor.&quot;" line747="    export function startbit_getSoundVolume(): number {" line748="        return volume;" line749="    }" line750="" line751="    /**" line752="    * Get the obstacle avoidance sensor status,1 detect obstacle,0 no detect obstacle" line753="    * Pin 1 with Port 1" line754="    * Pin 13 with Port 2" line755="    * Pin ADC with Port 3" line756="    */" line757="    //% weight=85 blockId=startbit_avoidSensor block=&quot;Obstacle avoidance sensor|port %port|detect obstacle&quot; group=&quot;3. Sensor.&quot;" line758="    export function startbit_avoidSensor(port: startbit_touchKeyPort): boolean {" line759="        let status = 0;" line760="        let flag: boolean = false;" line761="        switch (port) {" line762="            case startbit_touchKeyPort.port1:" line763="                pins.setPull(DigitalPin.P1, PinPullMode.PullUp);" line764="                status = pins.digitalReadPin(DigitalPin.P1);" line765="                break;" line766="            case startbit_touchKeyPort.port2:" line767="                pins.setPull(DigitalPin.P13, PinPullMode.PullUp);" line768="                status = pins.digitalReadPin(DigitalPin.P13);" line769="                break;" line770="            case startbit_touchKeyPort.port3:" line771="                if (P14_ad &gt; 0xA)" line772="                    status = 1" line773="                else" line774="                    status = 0;" line775="                break;" line776="        }" line777="        if (status == 1)" line778="            flag = false;" line779="        else" line780="            flag = true;" line781="        return flag;" line782="    }" line783="    /**" line784="    * Get the gas sensor status,0 detect gas,1 no detect gas" line785="    * Pin 1 with Port 1" line786="    * Pin 13 with Port 2" line787="    * Pin ADC with Port 3" line788="    */" line789="    //% weight=85 blockId=startbit_gasSensor block=&quot;gas sensor|port %port|detect Gas&quot; group=&quot;3. Sensor.&quot;  advanced=true" line790="    export function startbit_gasSensor(port: startbit_touchKeyPort): boolean {" line791="        let status2 = 0;" line792="        let flag2: boolean = false;" line793="        switch (port) {" line794="            case startbit_touchKeyPort.port1:" line795="                pins.setPull(DigitalPin.P1, PinPullMode.PullUp);" line796="                status2 = pins.digitalReadPin(DigitalPin.P1);" line797="                break;" line798="            case startbit_touchKeyPort.port2:" line799="                pins.setPull(DigitalPin.P13, PinPullMode.PullUp);" line800="                status2 = pins.digitalReadPin(DigitalPin.P13);" line801="                break;" line802="            case startbit_touchKeyPort.port3:" line803="                if (P14_ad &gt; 0xA)" line804="                    status2 = 1" line805="                else" line806="                    status2 = 0;" line807="                break;" line808="        }" line809="        if (status2 == 1)" line810="            flag2 = false;" line811="        else" line812="            flag2 = true;" line813="        return flag2;" line814="    }" line815="" line816="    /**" line817="    * Get the condition of the line follower sensor" line818="    */" line819="    //% weight=84 blockId=startbit_readLineFollowerStatus block=&quot;Line follower status|port %port|%status&quot; group=&quot;3. Sensor.&quot; " line820="    export function startbit_readLineFollowerStatus(port: startbit_lineFollowPort, status: startbit_lineFollower): boolean {" line821="        let s1 = 0;" line822="        let s2 = 0;" line823="        switch (port) {" line824="            case startbit_lineFollowPort.port1:" line825="                s1 = pins.analogReadPin(AnalogPin.P1);" line826="                s2 = pins.analogReadPin(AnalogPin.P2);" line827="                s1 = s1 * 255 / 1023;" line828="                s2 = s2 * 255 / 1023;" line829="                if (s1 &lt; 100)" line830="                    s1 = 0;" line831="                else" line832="                    s1 = 1;" line833="                if (s2 &lt; 100)" line834="                    s2 = 0;" line835="                else" line836="                    s2 = 1;" line837="                break;" line838="        }" line839="        let s = ((1 &amp; s1) &lt;&lt; 1) | s2;" line840="        if (s == status) {" line841="            return true;" line842="        }" line843="        else {" line844="            return false;" line845="        }" line846="    }" line847="" line848="    /**" line849="     * Get the line follower sensor port ad value" line850="     */" line851="    //% weight=83 blockId=startbit_lineSensorValue block=&quot;Get line follower sensor|port %port|%sensor|ad value&quot; group=&quot;3. Sensor.&quot;  advanced=true" line852="    export function startbit_lineSensorValue(port: startbit_lineFollowPort, sensor: startbit_LineFollowerSensor): number {" line853="        let s12 = 0;" line854="        let s22 = 0;" line855="        switch (port) {" line856="            case startbit_lineFollowPort.port1:" line857="                s12 = pins.analogReadPin(AnalogPin.P1);" line858="                s22 = pins.analogReadPin(AnalogPin.P2);" line859="                s12 = s12 * 255 / 1023;" line860="                s22 = s22 * 255 / 1023;" line861="                break;" line862="        }" line863="        if (sensor == startbit_LineFollowerSensor.LFSensor_1) {" line864="            return 255 - s12;" line865="        }" line866="        else {" line867="            return 255 - s22;" line868="        }" line869="" line870="    }" line871="" line872="" line873="    let distanceBak = 0;" line874="    /**" line875="     * Get the distance of ultrasonic detection to the obstacle " line876="     * Port 1: echo-P2, tri-P1" line877="     * Port 2: echo-P14, tri-P13" line878="     */" line879="    //% weight=81 blockId=startbit_ultrasonic  block=&quot;Ultrasonic|port %port|distance(cm)&quot; group=&quot;3. Sensor.&quot; " line880="    export function startbit_ultrasonic(port: startbit_ultrasonicPort): number {" line881="        let echoPin: DigitalPin;" line882="        let trigPin: DigitalPin;" line883="        switch (port) {" line884="            case startbit_ultrasonicPort.port1:" line885="                echoPin = DigitalPin.P2;" line886="                trigPin = DigitalPin.P1;" line887="                break;" line888="            case startbit_ultrasonicPort.port2:" line889="                echoPin = DigitalPin.P14;" line890="                trigPin = DigitalPin.P13;" line891="                break;" line892="        }" line893="        pins.setPull(echoPin, PinPullMode.PullNone);" line894="        pins.setPull(trigPin, PinPullMode.PullNone);" line895="" line896="        pins.digitalWritePin(trigPin, 0);" line897="        control.waitMicros(2);" line898="        pins.digitalWritePin(trigPin, 1);" line899="        control.waitMicros(10);" line900="        pins.digitalWritePin(trigPin, 0);" line901="        control.waitMicros(5);" line902="        let e = pins.pulseIn(echoPin, PulseValue.High, 25000);" line903="        let distance = e;" line904="        // filter timeout spikes" line905="        if (distance == 0 &amp;&amp; distanceBak != 0) {" line906="            distance = distanceBak;" line907="        }" line908="        distanceBak = e;" line909="        return Math.round(distance * 10 / 6 / 58);" line910="    }" line911="" line912="" line913="&#9;" line914="    /**" line915="    * Get the ad value of the photosensitive moudule" line916="    * Port 1: P1 --- analog " line917="    */" line918="    //% weight=79 blockId=startbit_getphotosensitiveValue  block=&quot;Get Photosensitive|port %port|value(0~255)&quot;  group=&quot;3. Sensor.&quot; " line919="    export function startbit_getphotosensitiveValue(port: startbit_photosensitivePort): number {" line920="        let adValue = pins.analogReadPin(AnalogPin.P1);" line921="        adValue = adValue * 255 / 1023;" line922="        return 255 - adValue;" line923="    }" line924="" line925="    /**" line926="    * Get the Photosensitive sensor status,1 detect bright,0 no detect bright" line927="    * Port 1: P2 --- digital" line928="    */" line929="    //% weight=78 blockId=startbit_photosensitiveSensor blockGap=50 block=&quot;Photosensitive sensor|port %port|detect bright&quot; group=&quot;3. Sensor.&quot;  advanced=true" line930="    export function startbit_photosensitiveSensor(port: startbit_PhotosensitiveSensor): boolean {" line931="        let status3 = 0;" line932="        let flag3: boolean = false;" line933="        switch (port) {" line934="            case startbit_PhotosensitiveSensor.port1:" line935="                pins.setPull(DigitalPin.P2, PinPullMode.PullUp);" line936="                status3 = pins.digitalReadPin(DigitalPin.P2);" line937="                break;" line938="        }" line939="        if (status3 == 1)" line940="            flag3 = false;" line941="        else" line942="            flag3 = true;" line943="        return flag3;" line944="    }" line945="" line946="" line947="" line948="" line949="    /**" line950="&#9; * Initialize RGB" line951="&#9; */" line952="    function startbit_initRGBLight() {" line953="        if (!lhRGBLight) {" line954="            lhRGBLight = StartbitRGBLight.create(DigitalPin.P15, 6, StartbitRGBPixelMode.RGB);" line955="        }" line956="        startbit_clearLight();" line957="    }" line958="" line959="    /**" line960="         * Set the brightness of the strip. This flag only applies to future operation." line961="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line962="    */" line963="    //% blockId=&quot;startbit_setBrightness&quot; block=&quot;set brightness %brightness&quot; group=&quot;1. Declaration.&quot;" line964="    //% weight=68" line965="    export function startbit_setBrightness(brightness: number): void {" line966="        lhRGBLight.setBrightness(brightness);" line967="    }" line968="" line969="    /**" line970="     * Set the color of the colored lights, after finished the setting please perform  the display of colored lights." line971="     */" line972="    //% weight=67 blockId=startbit_setPixelRGB block=&quot;Set|%lightoffset|color to %rgb&quot; group=&quot;4. The Light.&quot; " line973="    export function startbit_setPixelRGB(lightoffset: StartbitLights, rgb: StartbitRGBColors) {" line974="        lhRGBLight.setPixelColor(lightoffset, rgb);" line975="    }" line976="" line977="" line978="    /**" line979="     * Set RGB Color argument" line980="     */" line981="    //% weight=66 blockId=startbit_setPixelRGBArgs block=&quot;Set|%lightoffset|color to %rgb&quot; group=&quot;4. The Light.&quot;" line982="    export function startbit_setPixelRGBArgs(lightoffset: StartbitLights, rgb: number) {" line983="        lhRGBLight.setPixelColor(lightoffset, rgb);" line984="    }" line985="" line986="" line987="    /**" line988="     * Display the colored lights, and set the color of the colored lights to match the use. After setting the color of the colored lights, the color of the lights must be displayed." line989="     */" line990="    //% weight=65 blockId=startbit_showLight block=&quot;Show light&quot; group=&quot;4. The Light.&quot; " line991="    export function startbit_showLight() {" line992="        lhRGBLight.show();" line993="    }" line994="" line995="    /**" line996="     * Clear the color of the colored lights and turn off the lights." line997="     */" line998="    //% weight=64 blockGap=50 blockId=startbit_clearLight block=&quot;Clear light&quot; group=&quot;4. The Light.&quot;" line999="    export function startbit_clearLight() {" line1000="        lhRGBLight.clear();" line1001="    }" line1002="" line1003="    /**" line1004="&#9; * Initialize Light belt" line1005="&#9; */" line1006="    //% weight=63 blockId=startbit_belt_initRGBLight block=&quot;Initialize light belt at port %port&quot; group=&quot;1. Declaration.&quot;  advanced=true" line1007="    export function startbit_belt_initRGBLight(port: startbit_ultrasonicPort) {" line1008="        switch (port) {" line1009="            case startbit_ultrasonicPort.port1:" line1010="                if (!lhRGBLightBelt) {" line1011="                    lhRGBLightBelt = StartbitRGBLight.create(DigitalPin.P1, 30, StartbitRGBPixelMode.RGB);" line1012="                }" line1013="                break;" line1014="            case startbit_ultrasonicPort.port2:" line1015="                if (!lhRGBLightBelt) {" line1016="                    lhRGBLightBelt = StartbitRGBLight.create(DigitalPin.P13, 30, StartbitRGBPixelMode.RGB);" line1017="                }" line1018="                break;" line1019="        }" line1020="" line1021="        startbit_clearLight();" line1022="    }" line1023="" line1024="    /**" line1025="     * Set the color of the colored lights, after finished the setting please perform  the display of colored lights." line1026="     */" line1027="    //% weight=62 blockId=startbit_belt_setPixelRGB block=&quot;Set light belt|%lightoffset|color to %rgb&quot; group=&quot;4. The Light.&quot;  advanced=true" line1028="    export function startbit_belt_setPixelRGB(lightoffset: StartbitLightsBelt, rgb: StartbitRGBColors) {" line1029="        lhRGBLightBelt.setBeltPixelColor(lightoffset, rgb);" line1030="    }" line1031="" line1032="    /**" line1033="     * Display the colored lights, and set the color of the colored lights to match the use. After setting the color of the colored lights, the color of the lights must be displayed." line1034="     */" line1035="    //% weight=61 blockId=startbit_belt_showLight block=&quot;Show light belt&quot;group=&quot;4. The Light.&quot;  advanced=true" line1036="    export function startbit_belt_showLight() {" line1037="        lhRGBLightBelt.show();" line1038="    }" line1039="" line1040="    /**" line1041="     * Clear the color of the colored lights and turn off the lights." line1042="     */" line1043="    //% weight=60 blockGap=50 blockId=startbit_belt_clearLight block=&quot;Clear light belt&quot; group=&quot;4. The Light.&quot;  advanced=true" line1044="    export function startbit_belt_clearLight() {" line1045="        lhRGBLightBelt.clear();" line1046="    }" line1047="" line1048="    function mapRGB(x: number, in_min: number, in_max: number, out_min: number, out_max: number): number {" line1049="        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;" line1050="    }" line1051="" line1052="    /**" line1053="    * Get the condition of the touch button,press return 1,or return 0" line1054="    * Port 1: P1" line1055="    * Port 2: P13" line1056="    * port 3: " line1057="    */" line1058="    //% weight=82 blockId=startbit_touchButton block=&quot;Touch button|port %port|is pressed&quot;    group=&quot;5. Mechaincs.&quot; " line1059="    export function startbit_touchButton(port: startbit_touchKeyPort): boolean {" line1060="        let status4: boolean = false;" line1061="        switch (port) {" line1062="            case startbit_touchKeyPort.port1:" line1063="                pins.setPull(DigitalPin.P1, PinPullMode.PullUp);" line1064="                status4 = !pins.digitalReadPin(DigitalPin.P1);" line1065="                break;" line1066="            case startbit_touchKeyPort.port2:" line1067="                pins.setPull(DigitalPin.P13, PinPullMode.PullUp);" line1068="                status4 = !pins.digitalReadPin(DigitalPin.P13);" line1069="                break;" line1070="            case startbit_touchKeyPort.port3:" line1071="                if (P14_ad &gt; 0xA)" line1072="                    status4 = false;" line1073="                else" line1074="                    status4 = true;" line1075="                break;" line1076="        }" line1077="        return status4;" line1078="    }" line1079="    /**" line1080="    * Get the ad value of the knob moudule" line1081="    */" line1082="    //% weight=80 blockId=startbit_getKnobValue  block=&quot;Get knob|port %port|value(0~255)&quot; group=&quot;5. Mechaincs.&quot; advanced=true" line1083="    export function startbit_getKnobValue(port: startbit_knobPort): number {" line1084="        let adValue2 = pins.analogReadPin(AnalogPin.P1);" line1085="        adValue2 = adValue2 * 255 / 1023;" line1086="        return adValue2;" line1087="    }" line1088="" line1089="    " line1090="    /**" line1091="     *  LCD" line1092="     */" line1093="    export let LCD_I2C_ADDR = 0x3f" line1094="    let buf7 = 0x00" line1095="    let BK = 0x08" line1096="    let RS = 0x00" line1097="    let E = 0x04" line1098="" line1099="    function setReg(dat: number): void {" line1100="        pins.i2cWriteNumber(LCD_I2C_ADDR, dat, NumberFormat.UInt8BE, false)" line1101="        basic.pause(1)" line1102="    }" line1103="" line1104="    function send(dat: number): void {" line1105="        let f = dat &amp; 0xF0" line1106="        f |= BK" line1107="        f |= RS" line1108="        setReg(f)" line1109="        setReg(f | 0x04)" line1110="        setReg(f)" line1111="    }" line1112="" line1113="    function setcmd(cmd: number): void {" line1114="        RS = 0" line1115="        send(cmd)" line1116="        send(cmd &lt;&lt; 4)" line1117="    }" line1118="" line1119="    function setdat(dat: number): void {" line1120="        RS = 1" line1121="        send(dat)" line1122="        send(dat &lt;&lt; 4)" line1123="    }" line1124="" line1125="    function setI2CAddress(): void {" line1126="        setcmd(0x33)" line1127="        basic.pause(5)" line1128="        send(0x30)" line1129="        basic.pause(5)" line1130="        send(0x20)" line1131="        basic.pause(5)" line1132="        setcmd(0x28)" line1133="        setcmd(0x0C)" line1134="        setcmd(0x06)" line1135="        setcmd(0x01)" line1136="    } " line1137="" line1138="    /**" line1139="     * Initialize the I2C address" line1140="     */" line1141="    //% blockId=&quot;LCD_setAddress&quot; block=&quot; Initialize LCD1602 I2C |%port address |%myAddr&quot; group=&quot;1. Declaration.&quot;" line1142="    //% weight=51 blockExternalInputs=true" line1143="    export function setAddress(port: startbit_LCDPort, myAddr: I2C_ADDR): void {" line1144="        LCD_I2C_ADDR = myAddr" line1145="        setI2CAddress()" line1146="    }" line1147="" line1148="    /**" line1149="     * Initialize the I2C address (number)" line1150="     */" line1151="   // //% blockId=&quot;LCD_setAddress2&quot; block=&quot;LCD1602 I2C address %myAddr&quot; group=&quot;8. Display&quot; " line1152="    //% weight=50 blockExternalInputs=true" line1153="    //export function setAddress2(myAddr: number): void {" line1154="    //    LCD_I2C_ADDR = myAddr" line1155="    //    setI2CAddress()" line1156="    //}" line1157="    /*" line1158="    function AutoAddr() {" line1159="        let k = true" line1160="        let addr = 0x20" line1161="        let d1 = 0, d2 = 0" line1162="        while (k &amp;&amp; (addr &lt; 0x28)) {" line1163="            pins.i2cWriteNumber(addr, -1, NumberFormat.Int32LE)" line1164="            d1 = pins.i2cReadNumber(addr, NumberFormat.Int8LE) % 16" line1165="            pins.i2cWriteNumber(addr, 0, NumberFormat.Int16LE)" line1166="            d2 = pins.i2cReadNumber(addr, NumberFormat.Int8LE)" line1167="            if ((d1 == 7) &amp;&amp; (d2 == 0)) k = false" line1168="            else addr += 1" line1169="        }" line1170="        if (!k) return addr" line1171="         addr = 0x38" line1172="        while (k &amp;&amp; (addr &lt; 0x40)) {" line1173="            pins.i2cWriteNumber(addr, -1, NumberFormat.Int32LE)" line1174="            d1 = pins.i2cReadNumber(addr, NumberFormat.Int8LE) % 16" line1175="            pins.i2cWriteNumber(addr, 0, NumberFormat.Int16LE)" line1176="            d2 = pins.i2cReadNumber(addr, NumberFormat.Int8LE)" line1177="            if ((d1 == 7) &amp;&amp; (d2 == 0)) k = false" line1178="            else addr += 1" line1179="        }" line1180="        if (!k) return addr" line1181="        else return 0" line1182="    }" line1183="    */" line1184="" line1185="    /**" line1186="     * Automatically initialize the I2C address" line1187="     */" line1188="    // //% blockId=&quot;LCD_setAddress3&quot; block=&quot;Auto set LCD1602 I2C address&quot; group=&quot;8. Display&quot; " line1189="    //% weight=50" line1190="    //export function setAddress3(): void {" line1191="     //   LCD_I2C_ADDR = AutoAddr()" line1192="     //   setI2CAddress()" line1193="    //}  " line1194="" line1195="    /**" line1196="     * LCD clear " line1197="     */" line1198="    //% blockId=&quot;LCD_clear&quot; block=&quot;LCD clear&quot; group=&quot;8. Display&quot; " line1199="    //% weight=45" line1200="    export function clear(): void {" line1201="        setcmd(0x01)" line1202="    }" line1203="   " line1204="    /**" line1205="     * Setting backlight" line1206="     */" line1207="    //% blockId=&quot;LCD_backlight&quot; block=&quot;set LCD backlight %on&quot; group=&quot;8. Display&quot;  advanced=true" line1208="    //% weight=46" line1209="    export function set_backlight(on: on_off): void {" line1210="        if (on == 1)" line1211="            BK = 0x08" line1212="        else" line1213="            BK = 0x00" line1214="        setcmd(0x00)" line1215="    }" line1216="" line1217="    /**" line1218="     * Show string." line1219="     */" line1220="    //% blockId=&quot;LCD_Show&quot; block=&quot;set string %show&quot; group=&quot;8. Display&quot; " line1221="    //% weight=47" line1222="    export function set_LCD_Show(show: visibled): void {" line1223="        if (show == 1)" line1224="            setcmd(0x0C)" line1225="        else" line1226="            setcmd(0x08)" line1227="    }" line1228="" line1229="    function printChar(ch: number, x: number, y: number): void {" line1230="        if (x &gt;= 0) {" line1231="            let a = 0x80" line1232="            if (y == 1)" line1233="                a = 0xC0" line1234="&#9;    if (y == 2)" line1235="                a = 0x80 + 0x14" line1236="            if (y == 3)" line1237="                a = 0xC0 + 0x14" line1238="            a += x" line1239="            setcmd(a)" line1240="        }" line1241="        setdat(ch)" line1242="    }" line1243="" line1244="    /**" line1245="     * Show x, y string " line1246="     */" line1247="    //% blockId=&quot;LCD_putString&quot; block=&quot;LCD show string %s|on x:%x|y:%y&quot; group=&quot;8. Display&quot;   advanced=true" line1248="    //% weight=49 blockExternalInputs=true x.min=0 x.max=15 y.min=0 y.max=1" line1249="    export function putString(s: string, x: number, y: number): void {" line1250="        if (s.length &gt; 0) {" line1251="            let breakPoint = -1" line1252="            printChar(s.charCodeAt(0), x, y)" line1253="            if (y == 0)" line1254="                breakPoint = 16 - x" line1255="            for (let i = 1; i &lt; s.length; i++) {" line1256="                if (i == breakPoint)" line1257="                    printChar(s.charCodeAt(i), 0, 1)" line1258="                else" line1259="                    printChar(s.charCodeAt(i), -1, 0)" line1260="            }" line1261="        }" line1262="    }" line1263="&#9;" line1264="    /**" line1265="     * Show number" line1266="     */" line1267="    //% blockId=&quot;LCD_putNumber&quot; block=&quot;LCD show number %n|on x:%x|y:%y&quot; group=&quot;8. Display&quot;  " line1268="    //% weight=48 blockExternalInputs=true x.min=0 x.max=15 y.min=0 y.max=1" line1269="    export function putNumber(n: number, x: number, y: number): void {" line1270="        putString(n.toString(),x,y)" line1271="    }" line1272="" line1273="    /**" line1274="     * Shift Left" line1275="     */" line1276="    //% blockId=&quot;LCD_shl&quot; block=&quot;Shift Left&quot; group=&quot;8. Display&quot;   advanced=true" line1277="    //% weight=43" line1278="    export function shl(): void {" line1279="        setcmd(0x18)" line1280="    }" line1281="" line1282="    /**" line1283="     * Shift Right" line1284="     */" line1285="    //% blockId=&quot;LCD_shr&quot; block=&quot;Shift Right&quot; group=&quot;8. Display&quot;   advanced=true" line1286="    //% weight=42" line1287="    export function shr(): void {" line1288="        setcmd(0x1C)" line1289="    }" line1290="" line1291="        /**" line1292="        * TM1640 LED display" line1293="        */" line1294="       export class startbit_TM1640LEDs {" line1295="        buf: Buffer;" line1296="        clk: DigitalPin;" line1297="        dio: DigitalPin;" line1298="        _ON: number;" line1299="        brightness: number;" line1300="        count: number;  // number of LEDs" line1301="" line1302="        /**" line1303="         * initial TM1640" line1304="         */" line1305="        init(): void {" line1306="            pins.digitalWritePin(this.clk, 0);" line1307="            pins.digitalWritePin(this.dio, 0);" line1308="            this._ON = 8;" line1309="            this.buf = pins.createBuffer(this.count);" line1310="            this.clear();" line1311="        }" line1312="" line1313="        /**" line1314="         * Start " line1315="         */" line1316="        _start() {" line1317="            pins.digitalWritePin(this.dio, 0);" line1318="            pins.digitalWritePin(this.clk, 0);" line1319="        }" line1320="" line1321="        /**" line1322="         * Stop" line1323="         */" line1324="        _stop() {" line1325="            pins.digitalWritePin(this.dio, 0);" line1326="            pins.digitalWritePin(this.clk, 1);" line1327="            pins.digitalWritePin(this.dio, 1);" line1328="        }" line1329="" line1330="        /**" line1331="         * send command1" line1332="         */" line1333="        _write_data_cmd() {" line1334="            this._start();" line1335="            this._write_byte(TM1640_CMD1);" line1336="            this._stop();" line1337="        }" line1338="" line1339="        /**" line1340="         * send command3" line1341="         */" line1342="        _write_dsp_ctrl() {" line1343="            this._start();" line1344="            this._write_byte(TM1640_CMD3 | this._ON | this.brightness);" line1345="            this._stop();" line1346="        }" line1347="" line1348="        /**" line1349="         * send a byte to 2-wire interface" line1350="         */" line1351="        _write_byte(b: number) {" line1352="            for (let j = 0; j &lt; 8; j++) {" line1353="                pins.digitalWritePin(this.clk, 0);" line1354="                pins.digitalWritePin(this.dio, (b &gt;&gt; j) &amp; 1);" line1355="                pins.digitalWritePin(this.clk, 1);" line1356="" line1357="            }" line1358="            pins.digitalWritePin(this.clk, 1);" line1359="            pins.digitalWritePin(this.clk, 0);" line1360="        }" line1361="" line1362="        intensity(val: number = 7) {" line1363="            if (val &lt; 1) {" line1364="                this.off();" line1365="                return;" line1366="            }" line1367="            if (val &gt; 8) val = 8;" line1368="            this._ON = 8;" line1369="            this.brightness = val - 1;" line1370="            this._write_data_cmd();" line1371="            this._write_dsp_ctrl();" line1372="        }" line1373="" line1374="        /**" line1375="         * set data to TM1640, with given bit" line1376="         */" line1377="        _dat(bit: number, dat: number) {" line1378="            this._write_data_cmd();" line1379="            this._start();" line1380="            this._write_byte(TM1640_CMD2 | (bit % this.count))" line1381="            this._write_byte(dat);" line1382="            this._stop();" line1383="            this._write_dsp_ctrl();" line1384="        }" line1385="" line1386="" line1387="        showbit(num: number = 5, bit: number = 0) {" line1388="            this.buf[bit % this.count] = _SEGMENTS[num % 16]" line1389="            this._dat(bit, _SEGMENTS[num % 16])" line1390="        }" line1391="" line1392="        showNumber(num: number) {" line1393="            if (num &lt; 0) {" line1394="                this._dat(0, 0x40) // '-'" line1395="                num = -num" line1396="            }" line1397="            else" line1398="                this.showbit(Math.idiv(num, 1000) % 10)" line1399="            this.showbit(num % 10, 3)" line1400="            this.showbit(Math.idiv(num, 10) % 10, 2)" line1401="            this.showbit(Math.idiv(num, 100) % 10, 1)" line1402="        }" line1403="" line1404="        showHex(num: number) {" line1405="            if (num &lt; 0) {" line1406="                this._dat(0, 0x40) // '-'" line1407="                num = -num" line1408="            }" line1409="            else" line1410="                this.showbit((num &gt;&gt; 12) % 16)" line1411="            this.showbit(num % 16, 3)" line1412="            this.showbit((num &gt;&gt; 4) % 16, 2)" line1413="            this.showbit((num &gt;&gt; 8) % 16, 1)" line1414="        }" line1415="" line1416="" line1417="        showDP(bit: number = 1, show: boolean = true) {" line1418="            bit = bit % this.count" line1419="            if (show) this._dat(bit, this.buf[bit] | 0x80)" line1420="            else this._dat(bit, this.buf[bit] &amp; 0x7F)" line1421="        }" line1422="" line1423="        clear() {" line1424="            for (let k = 0; k &lt; this.count; k++) {" line1425="                this._dat(k, 0)" line1426="                this.buf[k] = 0" line1427="            }" line1428="        }" line1429="" line1430="        on() {" line1431="            this._ON = 8;" line1432="            this._write_data_cmd();" line1433="            this._write_dsp_ctrl();" line1434="        }" line1435="" line1436="        off() {" line1437="            this._ON = 0;" line1438="            this._write_data_cmd();" line1439="            this._write_dsp_ctrl();" line1440="        }" line1441="    }" line1442="    /**" line1443="     * TM 1640 Module." line1444="     * @param clk the CLK pin for TM1640, eg: DigitalPin.P1, P13" line1445="     * @param dio the DIO pin for TM1640, eg: DigitalPin.P2, P14" line1446="     * @param intensity the brightness of the LED, eg: 7" line1447="     * @param count the count of the LED, eg: 4" line1448="     */" line1449="    function startbit_TM1640create(port: startbit_digitaltubePort, intensity: number, count: number): startbit_TM1640LEDs {" line1450="        let digitaltube = new startbit_TM1640LEDs();" line1451="        switch (port) {" line1452="            case startbit_digitaltubePort.port1:" line1453="                digitaltube.clk = DigitalPin.P2;" line1454="                digitaltube.dio = DigitalPin.P1;" line1455="                break;" line1456="            case startbit_digitaltubePort.port2:" line1457="                digitaltube.clk = DigitalPin.P14;" line1458="                digitaltube.dio = DigitalPin.P13;" line1459="                break;" line1460="        }" line1461="" line1462="        if ((count &lt; 1) || (count &gt; 5)) count = 4;" line1463="        digitaltube.count = count;" line1464="        digitaltube.brightness = intensity;" line1465="        digitaltube.init();" line1466="        return digitaltube;" line1467="    }" line1468="" line1469="  /**" line1470="     * MT1640: Port 1: clk-P1, dio-P2 ; Port 2: clk-P13, dio-P14 ; " line1471="     * @param clk the CLK pin for TM1640, eg: DigitalPin.P1" line1472="     * @param dio the DIO pin for TM1640, eg: DigitalPin.P2" line1473="     * @param intensity the brightness of the LED, eg: 7" line1474="     * @param count the count of the LED, eg: 4" line1475="     */" line1476="    //% weight=77 blockId=startbit_digitaltube block=&quot;digitaltube|%port|intensity %intensity|LED count %count&quot; group=&quot;1. Declaration.&quot;  advanced=true " line1477="    export function startbit_digitaltube(port: startbit_digitaltubePort, intensity: number, count: number) { " line1478="        Digitaltube = startbit_TM1640create(port, intensity, count);" line1479="    }" line1480="" line1481="    /**" line1482="     * show a number. " line1483="     * @param num is a number, eg: 0" line1484="     */" line1485="    //% weight=76 blockId=startbit_showNumber block=&quot;digitaltube show number| %num&quot;  group=&quot;8. Display&quot;   advanced=true" line1486="    export function startbit_showNumber(num: number)  {" line1487="        Digitaltube.showNumber(num);" line1488="    }" line1489="" line1490="    /**" line1491="     * show a number in given position. " line1492="     * @param num number will show, eg: 5" line1493="     * @param bit the position of the LED, eg: 0" line1494="     */" line1495="    //% weight=75 blockId=startbit_showbit block=&quot;digitaltube show digit| %num|at %bit&quot;  group=&quot;8. Display&quot;   advanced=true" line1496="    export function startbit_showbit(num: number = 5, bit: number = 0) {" line1497="        Digitaltube.showbit(num, bit);" line1498="    }" line1499="" line1500="    /**" line1501="     * show a hex number. " line1502="     * @param num is a hex number, eg: 0" line1503="     */" line1504="    //% weight=74 blockId=startbit_showhex block=&quot;digitaltube show hex number| %num&quot;  group=&quot;8. Display&quot;   advanced=true" line1505="    export function startbit_showhex(num: number) {" line1506="        Digitaltube.showHex(num);" line1507="    }" line1508="" line1509="    /**" line1510="     * show or hide dot point. " line1511="     * @param bit is the position, eg: 1" line1512="     * @param show is show/hide dp, eg: true" line1513="     */" line1514="    //% weight=73 blockId=startbit_showDP block=&quot;digitaltube DotPoint at| %bit|show %show&quot;  group=&quot;8. Display&quot;   advanced=true" line1515="    export function startbit_showDP(bit: number = 1, show: boolean = true) {" line1516="        Digitaltube.showDP(bit, show);" line1517="    } " line1518="" line1519="    /**" line1520="     * set TM1640 intensity, range is [0-8], 0 is off." line1521="     * @param val the brightness of the TM1640, eg: 7" line1522="     */" line1523="    //% weight=72 blockId=startbit_intensity block=&quot; digitaltube set intensity %val&quot;  group=&quot;8. Display&quot;   advanced=true" line1524="    export function startbit_intensity(val: number = 7) {" line1525="        Digitaltube.intensity(val);" line1526="    } " line1527="" line1528="    /**" line1529="     * turn off LED. " line1530="     */" line1531="    //% weight=71 blockId=startbit_off block=&quot;turn off digitaltube&quot;  group=&quot;8. Display&quot;   advanced=true" line1532="    export function startbit_off() {" line1533="        Digitaltube.off();" line1534="    }" line1535="" line1536="    /**" line1537="     * turn on LED. " line1538="     */" line1539="    //% weight=70 blockId=startbit_on block=&quot;turn on digitaltube&quot;  group=&quot;8. Display&quot;   advanced=true" line1540="    export function startbit_on() {" line1541="        Digitaltube.on();" line1542="    }" line1543="" line1544="    /**" line1545="     * clear LED. " line1546="     */" line1547="    //%weight=69 blockId=startbit_clear blockGap=50 block=&quot;clear digitaltube&quot;  group=&quot;8. Display&quot;   advanced=true" line1548="    export function startbit_clear() {" line1549="        Digitaltube.clear();" line1550="    }  " line1551="}" numlines="1552"></mutation></block></statement></block></xml>